for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_m_t1 <- predict(spl3, newdata = data.frame(t = tp[i + 1] + dt, x11 = x11[j + 1]),
type = "response")
predict_m_t2 <- predict(spl3, newdata = data.frame(t = tp[i + 1] - dt, x11 = x11[j + 1]),
type = "response")
grad_lhs_m_data[i,j] <- (predict_m_t1 - predict_m_t2) / (2 * dt)
}
}
# Spatial gradients of MDE.
grad_rhs_m_dm <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_x1 <- predict(spl3, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] - h),
type = "response")
predict_x2 <- predict(spl3, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
predict_x3 <- predict(spl3, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] + h),
type = "response")
grad_rhs_m_dm[i, j] <- (predict_x3 + predict_x1 - 2 * predict_x2) / (h ^ 2)
}
}
grad_rhs_m_alpha <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_n <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
grad_rhs_m_alpha[i, j] <- predict_n
}
}
# Temporal gradients of tumour cells.
grad_lhs_n_data <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_n_t1 <- predict(spl, newdata = data.frame(t = tp[i + 1] + dt, x11 = x11[j + 1]),
type = "response")
predict_n_t2 <- predict(spl, newdata = data.frame(t = tp[i + 1] - dt, x11 = x11[j + 1]),
type = "response")
grad_lhs_n_data[i,j] <- (predict_n_t1 - predict_n_t2) / (2 * dt)
}
}
# Spatial gradients of tumour cells.
grad_rhs_n_dn <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_x1 <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] - h),
type = "response")
predict_x2 <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
predict_x3 <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] + h),
type = "response")
grad_rhs_n_dn[i, j] <- (predict_x3 + predict_x1 - 2 * predict_x2) / (h ^ 2)
}
}
grad_rhs_n_gamma <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_x1_n <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] - h),
type = "response")
predict_x2_n <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
predict_x3_n <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] + h),
type = "response")
predict_n.dash <- (predict_x3_n - predict_x1_n) / (2 * h)
predict_x1_f <- predict(spl2, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] - h),
type = "response")
predict_x2_f <- predict(spl2, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
predict_x3_f <- predict(spl2, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1] + h),
type = "response")
predict_f.dash <- (predict_x3_f - predict_x1_f) / (2 * h)
predict_f.ddash <- (predict_x3_f + predict_x1_f - 2 * predict_x2_f) / (h ^ 2)
grad_rhs_n_gamma[i, j] <- predict_n.dash * predict_f.dash + predict_x2_n * predict_f.ddash
}
}
grad_rhs_n_r <- matrix(0, (dim_row - 2), (dim_col - 2))
for (i in 1:(dim_row - 2)) {
for (j in 1:(dim_col - 2)) {
predict_n <- predict(spl, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
predict_f <- predict(spl2, newdata = data.frame(t = tp[i + 1], x11 = x11[j + 1]),
type = "response")
grad_rhs_n_r[i, j] <- predict_n*(1-predict_n-predict_f)
}
}
setwd("D:/Academia/Gradient matching revisit 2022/Normal errors/No measurement errors")
#Environment settings
rm(list = ls())
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = FALSE)
#Obtain gradient approximations
dist <- "normal"
grads <- approximate.gradients(ref.data.trun, x11, max.t, distribution = dist)
View(ref.data)
grads <- approximate.gradients(ref.data, x11, max.t, distribution = dist)
write_rds(grads, "Reference gradients GAM.rds")
#Write gradients predicted by GAM into a .txt file
write.table(grads, "Reference gradients GAM.txt")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
#Calculate percent error
perc.err <- (par.ests - true.values) / true.values * 100
print(perc.err)
#Environment settings
rm(list = ls())
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = FALSE)
#Obtain gradient approximations
dist <- "normal"
grads <- approximate.gradients(ref.data, x11, max.t, distribution = dist)
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
write_rds(grads, "Reference gradients GAM imaginary cells BC.rds")
#Write gradients predicted by GAM into a .txt file
write.table(grads, "Reference gradients GAM imaginary cells BC.txt")
setwd("D:/Academia/Gradient matching revisit 2022/Normal errors (imaginary cells BC with full data)")
library(readr)
library(latex2exp)
res.dir <- c("SimRes_ests")
boots.dir <- c("SimRes_boots2")
cv <- c(0.01, 0.025, 0.05, 0.075, 0.1)
cv.1.res <- read_rds(paste0("./", res.dir, "/cv1_sim_res.rds"))
cv.2.res <- read_rds(paste0("./", res.dir, "/cv2_sim_res.rds"))
cv.3.res <- read_rds(paste0("./", res.dir, "/cv3_sim_res.rds"))
cv.4.res <- read_rds(paste0("./", res.dir, "/cv4_sim_res.rds"))
cv.5.res <- read_rds(paste0("./", res.dir, "/cv5_sim_res.rds"))
cv.1.mean.vals <- apply(cv.1.res$par.ests, 2, mean)
cv.2.mean.vals <- apply(cv.2.res$par.ests, 2, mean)
cv.3.mean.vals <- apply(cv.3.res$par.ests, 2, mean)
cv.4.mean.vals <- apply(cv.4.res$par.ests, 2, mean)
cv.5.mean.vals <- apply(cv.5.res$par.ests, 2, mean)
ests.mat <- rbind(cv.1.mean.vals, cv.2.mean.vals, cv.3.mean.vals,
cv.4.mean.vals, cv.5.mean.vals)
cv.1.true.sd <- apply(cv.1.res$par.ests, 2, sd)
cv.2.true.sd <- apply(cv.2.res$par.ests, 2, sd)
cv.3.true.sd <- apply(cv.3.res$par.ests, 2, sd)
cv.4.true.sd <- apply(cv.4.res$par.ests, 2, sd)
cv.5.true.sd <- apply(cv.5.res$par.ests, 2, sd)
true.sd.mat <- rbind(cv.1.true.sd, cv.2.true.sd, cv.3.true.sd, cv.4.true.sd,
cv.5.true.sd)
cv.1.mean.sd <- apply(cv.1.res$sd.ests, 2, mean)
cv.2.mean.sd <- apply(cv.2.res$sd.ests, 2, mean)
cv.3.mean.sd <- apply(cv.3.res$sd.ests, 2, mean)
cv.4.mean.sd <- apply(cv.4.res$sd.ests, 2, mean)
cv.5.mean.sd <- apply(cv.5.res$sd.ests, 2, mean)
mean.sd.mat <- rbind(cv.1.mean.sd, cv.2.mean.sd, cv.3.mean.sd, cv.4.mean.sd,
cv.5.mean.sd)
cv1.boots.res <- read_rds(paste0("./", boots.dir, "/cv1_boot_res.rds"))
cv2.boots.res <- read_rds(paste0("./", boots.dir, "/cv2_boot_res.rds"))
cv3.boots.res <- read_rds(paste0("./", boots.dir, "/cv3_boot_res.rds"))
cv4.boots.res <- read_rds(paste0("./", boots.dir, "/cv4_boot_res.rds"))
cv5.boots.res <- read_rds(paste0("./", boots.dir, "/cv5_boot_res.rds"))
cv1.boots.sd <- apply(cv1.boots.res$boot.sd, 2, mean)
cv2.boots.sd <- apply(cv2.boots.res$boot.sd, 2, mean)
cv3.boots.sd <- apply(cv3.boots.res$boot.sd, 2, mean)
cv4.boots.sd <- apply(cv4.boots.res$boot.sd, 2, mean)
cv5.boots.sd <- apply(cv5.boots.res$boot.sd, 2, mean)
boot.sd.mat <- rbind(cv1.boots.sd, cv2.boots.sd, cv3.boots.sd, cv4.boots.sd,
cv5.boots.sd)
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n}$ (Gaussian errors)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
lines(boot.sd.mat[,1], lwd = 2, col = "red")
# gamma sd comparison
plot(true.sd.mat[,2], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2]),
max(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2])),
main = TeX("SD comparison $\\gamma$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,2], lwd = 2, col = "blue")
lines(boot.sd.mat[,2], lwd = 2, col = "red")
# rn sd comparison
plot(true.sd.mat[,3], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3]),
max(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3])),
main = TeX("SD comparison $r_{n}$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,3], lwd = 2, col = "blue")
lines(boot.sd.mat[,3], lwd = 2, col = "red")
# eta sd comparison
plot(true.sd.mat[,4], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4]),
max(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4])),
main = TeX("SD comparison $\\eta$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,4], lwd = 2, col = "blue")
lines(boot.sd.mat[,4], lwd = 2, col = "red")
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n}$ (Gaussian errors, ICBC)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
lines(boot.sd.mat[,1], lwd = 2, col = "red")
# gamma sd comparison
plot(true.sd.mat[,2], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2]),
max(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2])),
main = TeX("SD comparison $\\gamma$ (Gaussian errors, ICBC)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,2], lwd = 2, col = "blue")
lines(boot.sd.mat[,2], lwd = 2, col = "red")
# rn sd comparison
plot(true.sd.mat[,3], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3]),
max(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3])),
main = TeX("SD comparison $r_{n}$ (Gaussian errors, ICBC)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,3], lwd = 2, col = "blue")
lines(boot.sd.mat[,3], lwd = 2, col = "red")
# eta sd comparison
plot(true.sd.mat[,4], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4]),
max(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4])),
main = TeX("SD comparison $\\eta$ (Gaussian errors, ICBC)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,4], lwd = 2, col = "blue")
lines(boot.sd.mat[,4], lwd = 2, col = "red")
# dm sd comparison
plot(true.sd.mat[,5], type = "l", lwd = 2, col = "black",
main = TeX("SD comparison $d_{m}$ (Gaussian errors, ICBC)", bold = TRUE),
ylim = c(min(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5]),
max(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5])),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,5], lwd = 2, col = "blue")
lines(boot.sd.mat[,5], lwd = 2, col = "red")
# alpha sd comparison
plot(true.sd.mat[,6], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6]),
max(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6])),
main = TeX("SD comparison $\\alpha$ (Gaussian errors, ICBC)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,6], lwd = 2, col = "blue")
lines(boot.sd.mat[,6], lwd = 2, col = "red")
cv1_sim1_res <- readRDS("D:/Academia/Gradient matching revisit 2022/Normal errors (imaginary cells BC with full data)/SimRes_ests/cv1_sim1_res.rds")
cv1_sim2_res <- readRDS("D:/Academia/Gradient matching revisit 2022/Gamma errors (imaginary cells BC with truncated data)/SimRes_ests/cv1_sim2_res.rds")
View(cv1_sim1_res)
cv1_sim1_res[["ref.data"]][["n"]]
View(cv1_sim2_res)
cv1_sim2_res[["ref.data.trun"]][["n"]]
setwd("D:/Academia/Gradient matching revisit 2022/Normal errors (imaginary cells BC with full data)/Gradient plots")
# Gradients averaged over time and data sets.R
# Author: Yunchen Xiao
rm(list = ls())
in.dir <- "SimRes_ests"
n.sims <- 200
# dndt (Tumour cells temporal gradients)
mean.temp.gradients.n <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.lhs_n
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.n[i, ] <- temp.grad.cvi.mean
}
in.dir <- "SimRes_ests"
n.sims <- 200
# dndt (Tumour cells temporal gradients)
mean.temp.gradients.n <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.lhs_n
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.n[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.n, "Mean temporal grads tc.txt")
# dn gradients
mean.temp.gradients.dn <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_dn
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.dn[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.dn, "Mean spatial grads dn.txt")
# gamma gradients
mean.temp.gradients.gamma <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_gamma
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.gamma[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.gamma, "Mean spatial grads gamma.txt")
# rn gradients
mean.temp.gradients.rn <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_r
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.rn[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.rn, "Mean spatial grads rn.txt")
# dfdt (ECM temporal gradients)
mean.temp.gradients.ecm <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.lhs_f
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.ecm[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.ecm, "Mean temporal grads ecm.txt")
# eta gradients
mean.temp.gradients.ita <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_ita
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.ita[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.ita, "Mean spatial grads ita.txt")
# dmdt (Temporal gradients of MDE)
mean.temp.gradients.mde <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.lhs_m
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.mde[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.mde, "Mean temporal grads mde.txt")
# dm gradients
mean.temp.gradients.dm <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_dm
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.dm[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.dm, "Mean spatial grads dm.txt")
# alpha gradients
mean.temp.gradients.alpha <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.rhs_alpha
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.alpha[i, ] <- temp.grad.cvi.mean
}
write.table(mean.temp.gradients.alpha, "Mean spatial grads alpha.txt")
ref.grads.gam <- read.table("Reference gradients GAM imaginary cells BC.txt", sep = "", header = TRUE)
tc.temp.mean <- apply(as.matrix(ref.grads.gam[1:9, 1:78]), 2, mean)
dn.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 79:156]), 2, mean)
ga.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 157:234]), 2, mean)
rn.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 235:312]), 2, mean)
ecm.temp.mean <- apply(as.matrix(ref.grads.gam[1:9, 313:390]), 2, mean)
eta.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 391:468]), 2, mean)
mde.temp.mean <- apply(as.matrix(ref.grads.gam[1:9, 469:546]), 2, mean)
dm.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 547:624]), 2, mean)
alpha.spat.mean <- apply(as.matrix(ref.grads.gam[1:9, 625:702]), 2, mean)
ref.grad.gam.mean <- rbind(tc.temp.mean, dn.spat.mean, ga.spat.mean, rn.spat.mean,
ecm.temp.mean, eta.spat.mean, mde.temp.mean, dm.spat.mean,
alpha.spat.mean)
write.table(ref.grad.gam.mean, "Mean reference data grads gam.txt")
ref.grads.fds <- read.table("True gradients forward difference scheme imaginary cells BC.txt", sep = "", header = TRUE)
tc.temp.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 1:78]), 2, mean)
dn.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 79:156]), 2, mean)
ga.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 157:234]), 2, mean)
rn.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 235:312]), 2, mean)
ecm.temp.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 313:390]), 2, mean)
eta.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 391:468]), 2, mean)
mde.temp.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 469:546]), 2, mean)
dm.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 547:624]), 2, mean)
alpha.spat.mean.fds <- apply(as.matrix(ref.grads.fds[1:9, 625:702]), 2, mean)
ref.grad.fds.mean <- rbind(tc.temp.mean.fds, dn.spat.mean.fds, ga.spat.mean.fds, rn.spat.mean.fds,
ecm.temp.mean.fds, eta.spat.mean.fds, mde.temp.mean.fds, dm.spat.mean.fds,
alpha.spat.mean.fds)
write.table(ref.grad.fds.mean, "Mean reference data grads fds.txt")
