# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#Start values for optimizations
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
grads <- read_rds("Reference gradients GAM imaginary cells BC.rds")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Gamma errors (imaginary cells BC with truncated data)/Gradient plots")
rm(list = ls())
# 1D dimensionless space
n.x11 <- 80
x11 <- seq(0, 1, length = n.x11)
h <- x11[2] - x11[1]
# Time
T <- 10
dt <- 0.001
t <- seq(0, T, by = 0.001)
int.timesteps <- 1 / dt
# Parameters
dn <- 0.01
gamma <- 0.05
ita <- 10
dm <- 0.01
alpha <- 0.1
r <- 5
beta <- 0
eps <- 0.01
# Initial condition
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp((-x11[i] ^ 2) / eps)
} else {
n0[i] <- 0
}
}
n <- n0
f0 <- 1 - 0.5 * n0
f <- f0
m0 <- 0.5 * n0
m <- m0
# Store the initial values into the result matrix
res <- matrix(0, 3, n.x11)
res [1, ] <- n0
res [2, ] <- f0
res [3, ] <- m0
res.full <- res
# Run the equation
p <- 1
while(p * dt <= T) {
f[2:(n.x11 - 1)] <- -ita * dt * m[2:(n.x11 - 1)] * f[2:(n.x11 - 1)] +
f[2:(n.x11 - 1)]
m[2:(n.x11 - 1)] <- dm * (m[1:(n.x11 - 2)] + m[3:n.x11] - 2 * m[2:(n.x11 - 1)]) * dt / (h ^ 2) +
alpha * n[2:(n.x11 - 1)] * dt -
beta * m[2:(n.x11 - 1)] * dt + m[2:(n.x11 - 1)]
n[2:(n.x11 - 1)] <- dn * (n[1:(n.x11 - 2)] + n[3:n.x11] - 2 * n[2:(n.x11 - 1)]) * dt / (h ^ 2) -
gamma * (n[3:n.x11] - n[2:(n.x11 - 1)]) * (f[3:n.x11]-f[2:(n.x11 - 1)]) * dt / (h ^ 2) -
gamma * n[2:(n.x11 - 1)] * (f[1:(n.x11 - 2)] + f[3:n.x11] - 2 * f[2:(n.x11 - 1)]) * dt / (h ^ 2) +
r * (1 - f[2:(n.x11 - 1)] - n[2:(n.x11 - 1)]) * n[2:(n.x11 - 1)] * dt + n[2:(n.x11 - 1)]
#No flux boundary condition
n[1] <- dn * (n[2] - 2 * n[1] + n[2]) * dt / (h ^ 2) -
gamma * (n[2] - n[1]) * (f[2] - f[1]) * dt / (h ^ 2) -
gamma * n[1] * (f[2] + f[2] - 2 * f[1]) * dt / (h ^ 2) +
r * (1 - f[1] - n[1]) * n[1] * dt + n[1]
n[n.x11] <- dn * (n[n.x11 - 1] - 2 * n[n.x11] + n[n.x11 - 1]) * dt / (h ^ 2) -
gamma * (n[n.x11 - 1] - n[n.x11]) * (f[n.x11 - 1] - f[n.x11]) * dt / (h ^ 2) -
gamma * n[n.x11] * (f[n.x11 - 1] + f[n.x11 - 1] - 2 * f[n.x11]) * dt / (h ^ 2) +
r * (1 - f[n.x11] - n[n.x11]) * n[n.x11] * dt + n[n.x11]
f[1] <- -ita * dt * m[1] * f[1] + f[1]
f[n.x11] <- -ita * dt * m[n.x11] * f[n.x11] + f[n.x11]
m[1] <- dm * (m[2] - 2 * m[1] + m[2]) * dt / (h ^ 2) +
alpha * n[1] * dt - beta * m[1] * dt + m[1]
m[n.x11] <- dm * (m[n.x11 - 1] - 2 * m[n.x11] + m[n.x11 - 1]) * dt / (h ^ 2) +
alpha * n[n.x11] * dt - beta * m[n.x11] * dt + m[n.x11]
res.full <- rbind(res.full,n,f,m)
# Save the results at each integer time steps
if(p %% int.timesteps == 0) {
res <- rbind(res, n, f, m)
}
p <- p + 1
}
# Separate results of n, f and m at the 11 integer timepoints.
n.res <- res[seq(1, (length(res[, 1]) - 2), by = 3), ]
f.res <- res[seq(2, (length(res[, 1]) - 1), by = 3), ]
m.res <- res[seq(3, length(res[, 1]), by = 3), ]
# Separate full results of n, f and m
n.res.full <- res.full[seq(1, (length(res.full[, 1]) - 2), by = 3), ]
f.res.full <- res.full[seq(2, (length(res.full[, 1]) - 1), by = 3), ]
m.res.full <- res.full[seq(3, length(res.full[, 1]), by = 3), ]
ind <- seq(0, 10, by = 0.001)
# dndt
dndt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dndt[, 1])) {
for (j in 1:length(dndt[1,])) {
dndt[i,j] <- (n.res.full[(i * 1000 + 2), (j + 1)] - n.res.full[(i * 1000), (j + 1)])/(2*dt)
}
}
# dfdt
dfdt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dfdt[, 1])) {
for (j in 1:length(dfdt[1, ])) {
dfdt[i,j] <- (f.res.full[(i * 1000 + 2), (j + 1)] - f.res.full[(i * 1000), (j + 1)]) / (2 * dt)
}
}
# dmdt
dmdt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dmdt[, 1])) {
for (j in 1:length(dmdt[1, ])) {
dmdt[i,j] <- (m.res.full[(i * 1000 + 2), (j + 1)] - m.res.full[(i * 1000), (j + 1)]) / (2 * dt)
}
}
# dn (second order derivative)
d2ndx2 <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(d2ndx2[, 1])) {
for (j in 1:length(d2ndx2[1, ])) {
d2ndx2[i,j] <- (n.res.full[(i * 1000 + 1), (j + 2)] + n.res.full[(i * 1000 + 1), j]
- 2 * n.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
}
}
# gamma (haptotaxis)
hap <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(hap[, 1])) {
for (j in 1:length(hap[1, ])) {
dndx.temp <- (n.res.full[(i * 1000 + 1), (j + 2)] - n.res.full[(i * 1000 + 1), j]) / (2 * h)
dfdx.temp <- (f.res.full[(i * 1000 + 1), (j + 2)] - f.res.full[(i * 1000 + 1), j]) / (2 * h)
n.temp <- n.res.full[(i * 1000 + 1), (j + 1)]
d2fdx2.temp <- (f.res.full[(i * 1000 + 1), (j + 2)] + f.res.full[(i * 1000 + 1), j]
- 2 * f.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
hap[i, j] <- dndx.temp * dfdx.temp + n.temp * d2fdx2.temp
}
}
# rn (logistic growth)
logis <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(logis[, 1])) {
for (j in 1:length(logis[1, ])) {
logis[i, j] <- n.res.full[(i * 1000 + 1), (j + 1)] * (1 - n.res.full[(i * 1000 + 1), (j + 1)] -
f.res.full[(i * 1000 + 1), (j + 1)])
}
}
# eta (decay of ecm)
mf <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(logis[, 1])) {
for (j in 1:length(logis[1, ])) {
mf[i, j] <- m.res.full[(i * 1000 + 1), (j + 1)] * f.res.full[(i * 1000 + 1), (j + 1)]
}
}
# dm (second order derivative)
d2mdx2 <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(d2mdx2[, 1])) {
for (j in 1:length(d2mdx2[1, ])) {
d2mdx2[i,j] <- (m.res.full[(i * 1000 + 1), (j + 2)] + m.res.full[(i * 1000 + 1), j]
- 2 * m.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
}
}
# alpha (growth of mde)
tc.den <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(tc.den[, 1])) {
for (j in 1:length(tc.den[1, ])) {
tc.den[i,j] <- n.res.full[(i * 1000 + 1), (j + 1)]
}
}
# Write the true gradients into a .txt file
ref.grads.fds <- cbind(dndt, d2ndx2, hap, logis, dfdt, mf, dmdt, d2mdx2, tc.den)
View(ref.grads.fds)
# Gradients averaged over time and data sets.R
# Author: Yunchen Xiao
rm(list = ls())
in.dir <- "SimRes_ests"
n.sims <- 200
# dndt (Tumour cells temporal gradients)
mean.temp.gradients.n <- matrix(0, nrow = 5, ncol = 78)
for (i in 1:5) {
temp.grad.cvi <- matrix(0, nrow = 9, ncol = 78)
for (j in 1:n.sims) {
temp.res <- readr::read_rds(paste0("./", in.dir, "/cv", i, "_sim", j, "_res.rds"))$grads
temp.grad <- temp.res$grad.lhs_n
temp.grad.cvi <- temp.grad.cvi + temp.grad
}
temp.grad.cvi <- temp.grad.cvi / n.sims
temp.grad.cvi.mean <- apply(temp.grad.cvi, 2, mean)
mean.temp.gradients.n[i, ] <- temp.grad.cvi.mean
}
View(mean.temp.gradients.n)
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Gamma errors (imaginary cells BC with truncated data)/No measurement errors")
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Gamma errors (normal BC with truncated data)/Results without measurement errors")
#Environment settings
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
#Environment settings
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data.trun <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = TRUE)
#Obtain gradient approximations
dist <- "gamma"
#write_rds(grads, "Reference gradients GAM.rds")
grads <- read_rds("Reference gradients GAM.rds")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
#Calculate percent error
perc.err <- (par.ests - true.values) / true.values * 100
print(perc.err)
cv1_sim1_res <- readRDS("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Normal errors (imaginary cells BC with full data)/SimRes_ests/cv1_sim1_res.rds")
View(cv1_sim1_res)
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Normal errors (imaginary cells BC with full data)/No measurement errors")
#Environment settings
rm(list = ls())
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
grads <- read_rds("Reference gradients GAM imaginary cells BC.rds")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
rm(list = ls())
# 1D dimensionless space
n.x11 <- 80
x11 <- seq(0, 1, length = n.x11)
h <- x11[2] - x11[1]
# Time
T <- 10
dt <- 0.001
t <- seq(0, T, by = 0.001)
int.timesteps <- 1 / dt
# Parameters
dn <- 0.01
gamma <- 0.05
ita <- 10
dm <- 0.01
alpha <- 0.1
r <- 5
beta <- 0
eps <- 0.01
# Initial condition
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp((-x11[i] ^ 2) / eps)
} else {
n0[i] <- 0
}
}
n <- n0
f0 <- 1 - 0.5 * n0
f <- f0
m0 <- 0.5 * n0
m <- m0
# Store the initial values into the result matrix
res <- matrix(0, 3, n.x11)
res [1, ] <- n0
res [2, ] <- f0
res [3, ] <- m0
res.full <- res
# Run the equation
p <- 1
while(p * dt <= T) {
f[2:(n.x11 - 1)] <- -ita * dt * m[2:(n.x11 - 1)] * f[2:(n.x11 - 1)] +
f[2:(n.x11 - 1)]
m[2:(n.x11 - 1)] <- dm * (m[1:(n.x11 - 2)] + m[3:n.x11] - 2 * m[2:(n.x11 - 1)]) * dt / (h ^ 2) +
alpha * n[2:(n.x11 - 1)] * dt -
beta * m[2:(n.x11 - 1)] * dt + m[2:(n.x11 - 1)]
n[2:(n.x11 - 1)] <- dn * (n[1:(n.x11 - 2)] + n[3:n.x11] - 2 * n[2:(n.x11 - 1)]) * dt / (h ^ 2) -
gamma * (n[3:n.x11] - n[2:(n.x11 - 1)]) * (f[3:n.x11]-f[2:(n.x11 - 1)]) * dt / (h ^ 2) -
gamma * n[2:(n.x11 - 1)] * (f[1:(n.x11 - 2)] + f[3:n.x11] - 2 * f[2:(n.x11 - 1)]) * dt / (h ^ 2) +
r * (1 - f[2:(n.x11 - 1)] - n[2:(n.x11 - 1)]) * n[2:(n.x11 - 1)] * dt + n[2:(n.x11 - 1)]
#No flux boundary condition
n[1] <- dn * (n[2] - 2 * n[1] + n[2]) * dt / (h ^ 2) -
gamma * (n[2] - n[1]) * (f[2] - f[1]) * dt / (h ^ 2) -
gamma * n[1] * (f[2] + f[2] - 2 * f[1]) * dt / (h ^ 2) +
r * (1 - f[1] - n[1]) * n[1] * dt + n[1]
n[n.x11] <- dn * (n[n.x11 - 1] - 2 * n[n.x11] + n[n.x11 - 1]) * dt / (h ^ 2) -
gamma * (n[n.x11 - 1] - n[n.x11]) * (f[n.x11 - 1] - f[n.x11]) * dt / (h ^ 2) -
gamma * n[n.x11] * (f[n.x11 - 1] + f[n.x11 - 1] - 2 * f[n.x11]) * dt / (h ^ 2) +
r * (1 - f[n.x11] - n[n.x11]) * n[n.x11] * dt + n[n.x11]
f[1] <- -ita * dt * m[1] * f[1] + f[1]
f[n.x11] <- -ita * dt * m[n.x11] * f[n.x11] + f[n.x11]
m[1] <- dm * (m[2] - 2 * m[1] + m[2]) * dt / (h ^ 2) +
alpha * n[1] * dt - beta * m[1] * dt + m[1]
m[n.x11] <- dm * (m[n.x11 - 1] - 2 * m[n.x11] + m[n.x11 - 1]) * dt / (h ^ 2) +
alpha * n[n.x11] * dt - beta * m[n.x11] * dt + m[n.x11]
#n[1] <- n[2]
#n[n.x11] <- n[n.x11 - 1]
#f[1] <- f[2]
#f[n.x11] <- f[n.x11 - 1]
#m[1] <- m[2]
#m[n.x11] <- m[n.x11 - 1]
res.full <- rbind(res.full,n,f,m)
# Save the results at each integer time steps
if(p %% int.timesteps == 0) {
res <- rbind(res, n, f, m)
}
p <- p + 1
}
# Separate results of n, f and m at the 11 integer timepoints.
n.res <- res[seq(1, (length(res[, 1]) - 2), by = 3), ]
f.res <- res[seq(2, (length(res[, 1]) - 1), by = 3), ]
m.res <- res[seq(3, length(res[, 1]), by = 3), ]
# Separate full results of n, f and m
n.res.full <- res.full[seq(1, (length(res.full[, 1]) - 2), by = 3), ]
f.res.full <- res.full[seq(2, (length(res.full[, 1]) - 1), by = 3), ]
m.res.full <- res.full[seq(3, length(res.full[, 1]), by = 3), ]
ind <- seq(0, 10, by = 0.001)
View(res.full)
# dndt
dndt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dndt[, 1])) {
for (j in 1:length(dndt[1,])) {
dndt[i,j] <- (n.res.full[(i * 1000 + 2), (j + 1)] - n.res.full[(i * 1000), (j + 1)])/(2*dt)
}
}
# dfdt
dfdt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dfdt[, 1])) {
for (j in 1:length(dfdt[1, ])) {
dfdt[i,j] <- (f.res.full[(i * 1000 + 2), (j + 1)] - f.res.full[(i * 1000), (j + 1)]) / (2 * dt)
}
}
# dmdt
dmdt <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(dmdt[, 1])) {
for (j in 1:length(dmdt[1, ])) {
dmdt[i,j] <- (m.res.full[(i * 1000 + 2), (j + 1)] - m.res.full[(i * 1000), (j + 1)]) / (2 * dt)
}
}
# dn (second order derivative)
d2ndx2 <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(d2ndx2[, 1])) {
for (j in 1:length(d2ndx2[1, ])) {
d2ndx2[i,j] <- (n.res.full[(i * 1000 + 1), (j + 2)] + n.res.full[(i * 1000 + 1), j]
- 2 * n.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
}
}
# gamma (haptotaxis)
hap <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(hap[, 1])) {
for (j in 1:length(hap[1, ])) {
dndx.temp <- (n.res.full[(i * 1000 + 1), (j + 2)] - n.res.full[(i * 1000 + 1), j]) / (2 * h)
dfdx.temp <- (f.res.full[(i * 1000 + 1), (j + 2)] - f.res.full[(i * 1000 + 1), j]) / (2 * h)
n.temp <- n.res.full[(i * 1000 + 1), (j + 1)]
d2fdx2.temp <- (f.res.full[(i * 1000 + 1), (j + 2)] + f.res.full[(i * 1000 + 1), j]
- 2 * f.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
hap[i, j] <- dndx.temp * dfdx.temp + n.temp * d2fdx2.temp
}
}
# rn (logistic growth)
logis <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(logis[, 1])) {
for (j in 1:length(logis[1, ])) {
logis[i, j] <- n.res.full[(i * 1000 + 1), (j + 1)] * (1 - n.res.full[(i * 1000 + 1), (j + 1)] -
f.res.full[(i * 1000 + 1), (j + 1)])
}
}
# eta (decay of ecm)
mf <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(logis[, 1])) {
for (j in 1:length(logis[1, ])) {
mf[i, j] <- m.res.full[(i * 1000 + 1), (j + 1)] * f.res.full[(i * 1000 + 1), (j + 1)]
}
}
# dm (second order derivative)
d2mdx2 <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(d2mdx2[, 1])) {
for (j in 1:length(d2mdx2[1, ])) {
d2mdx2[i,j] <- (m.res.full[(i * 1000 + 1), (j + 2)] + m.res.full[(i * 1000 + 1), j]
- 2 * m.res.full[(i * 1000 + 1), (j + 1)]) / (h ^ 2)
}
}
# alpha (growth of mde)
tc.den <- matrix(0, nrow = 9, ncol = (n.x11 - 2))
for (i in 1:length(tc.den[, 1])) {
for (j in 1:length(tc.den[1, ])) {
tc.den[i,j] <- n.res.full[(i * 1000 + 1), (j + 1)]
}
}
# Write the true gradients into a .txt file
ref.grads.fds <- cbind(dndt, d2ndx2, hap, logis, dfdt, mf, dmdt, d2mdx2, tc.den)
View(ref.grads.fds)
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Normal errors (normal BC with full data)")
setwd("D:/Academia/1D material revisit 2022/Gradient matching revisit 2022/Normal errors (normal BC with full data)/No measurement errors")
#Environment settings
rm(list = ls())
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
grads <- read_rds("Reference gradients GAM.rds")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
#Calculate percent error
perc.err <- (par.ests - true.values) / true.values * 100
print(perc.err)
