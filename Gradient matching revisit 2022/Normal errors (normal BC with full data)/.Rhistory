mean.sd.mat <- rbind(cv.1.mean.sd, cv.2.mean.sd, cv.3.mean.sd, cv.4.mean.sd,
cv.5.mean.sd)
View(mean.sd.mat)
View(sd.ests)
View(true.sd.mat)
write.table(ests.mat, "Parameter estimates 5 cv.txt")
write.table(ests.mat, "True SD estimates 5 cv.txt")
write.table(true.sd.mat, "True SD estimates 5 cv.txt")
write.table(mean.sd.mat, "Mean SD estimates 5 cv.txt")
#Environment settings
library(readr)
rm(list = ls())
#Environment settings
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data.trun <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = TRUE)
### Gradient matching scheme ########
### Author: Yunchen Xiao & Len Thomas ###########
rm(list = ls())
#Source companion functions
source("PDE_GradientMatching_Functions.r")
#Load the package "tictoc" in order to measure the computational time.
library(tictoc)
setwd("~/Academia Yunchen/Gradient matching revisit 2022")
### Gradient matching scheme ########
### Author: Yunchen Xiao & Len Thomas ###########
rm(list = ls())
setwd("~/Academia Yunchen/Gradient matching revisit 2022/No measurement errors")
#Environment settings
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data.trun <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = TRUE)
View(ref.data.trun)
#Obtain gradient approximations
dist <- "gamma"
grads <- approximate.gradients(ref.data.trun, x11, max.t, distribution = dist)
write_rds(grads, "Reference gradients GAM.rds")
#Write gradients predicted by GAM into a .txt file
write.table(grads, "Reference gradients GAM.txt")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
View(res)
par.ests <- res$par
print(par.ests)
#Environment settings
rm(list = ls())
library(readr)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
#No parameters fixed here, so set fixed par to 6 NAs
fixed.par <- rep(NA, 6)
is.estimated <- is.na(fixed.par)
n.estimated <- sum(is.estimated)
#For optimization, use start values from manuscript
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
#Trim to only those for which parameters are being estimated
start.values <- start.values[is.estimated]
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
f0 <- 1-0.5*n0
m0 <- 0.5*n0
#Generate reference dataset
ref.data.trun <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0, truncate = TRUE)
View(ref.data.trun)
#Obtain gradient approximations
dist <- "gamma"
grads <- approximate.gradients(ref.data.trun, x11, max.t, distribution = dist)
write_rds(grads, "Reference gradients GAM.rds")
#Write gradients predicted by GAM into a .txt file
write.table(grads, "Reference gradients GAM.txt")
#Estimate parameter values
res <- optim(start.values, calculate.sse, grads = grads, fixed.par = fixed.par,
control = list(trace = 1, maxit = 20000, reltol = 1e-10))
par.ests <- res$par
print(par.ests)
#Source companion functions
source("PDE_GradientMatching_Functions.r")
#readr used to read and write results to file
library(readr)
#Load packages for running the simulation in parallel
library(doParallel)
library(doRNG)
#Directory to read sim results from and write bootstrap results to
save.sims <- TRUE
in.dir <- "SimRes_ests"
save.sims.dir <- "SimRes_boots2"
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
setwd("~/Academia Yunchen/Gradient matching revisit 2022")
#Source companion functions
source("PDE_GradientMatching_Functions.r")
#readr used to read and write results to file
library(readr)
#Load packages for running the simulation in parallel
library(doParallel)
library(doRNG)
#Directory to read sim results from and write bootstrap results to
save.sims <- TRUE
rm(list = ls())
#Source companion functions
source("PDE_GradientMatching_Functions.r")
#readr used to read and write results to file
library(readr)
#Load packages for running the simulation in parallel
library(doParallel)
library(doRNG)
#Directory to read sim results from and write bootstrap results to
save.sims <- TRUE
in.dir <- "SimRes_ests"
save.sims.dir <- "SimRes_boots2"
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
#Measurement error CVs that were run
cv <- c(0.01, 0.025, 0.05, 0.075, 0.10)
n.cvs <- length(cv)
#Number of bootstrap replicates to calculate SD
B <- 200
#Start values to use for parameters in optim
start.values <- c(0.01, 0.133, 6.25, 12.5, 0.0166, 0.125)
n.pars <- length(start.values)
#Set random number seed so results are reproducible
# (random number set within each level of CV to make any repeat runs of a
#  single CV level easier)
rn.seed <- 762905
#Number of parallel threads to run on
n.threads <- detectCores() - 1
#Number of parallel threads to run on
n.threads <- detectCores()/2
dim.grads <- dim(read_rds(paste0(in.dir, "/cv1_sim1_res.rds"))$grads[[1]])
n.data <- prod(dim.grads)
n.sims <- nrow(read_rds(paste0(in.dir, "/cv1_sim_res.rds"))$par.ests)
boot.res <- matrix(NA, B, n.pars)
cl <- makeCluster(n.threads)
registerDoParallel(cl)
#Set parallel seed - once = TRUE means it's set each time foreach is called
registerDoRNG(rn.seed, once = TRUE)
for(i in 1:n.cvs) {
ests <- foreach (k = 1:n.sims, .combine = rbind) %dopar% {
sim <- readr::read_rds(paste0(in.dir, "/cv", i, "_sim", k, "_res.rds"))
boot.grads <- sim$grads
for (b in 1:B) {
new.dat.ind <- sample.int(n.data, replace = TRUE)
for(l in 1:length(sim$grads))
boot.grads[[l]] <- matrix(as.numeric(sim$grads[[l]])[new.dat.ind],
dim.grads[1], dim.grads[2])
boot.res.temp <- optim(start.values, calculate.sse, grads = boot.grads,
control = list(trace = 1, maxit = 20000))
if (boot.res.temp$convergence > 0) warning("Optim did not converge")
boot.res[b, ] <- boot.res.temp$par
}
readr::write_rds(boot.res, paste0(save.sims.dir, "/cv", i, "_sim", k, "_boot_res.rds"))
boot.mean <- apply(boot.res, 2, mean)
boot.sd <- apply(boot.res, 2, sd)
#Vector to return from the foreach
c(boot.mean, boot.sd)
}
boot.mean <- ests[, 1:n.pars]
boot.sd <- ests[, 1:n.pars + n.pars]
readr::write_rds(list(boot.mean = boot.mean, boot.sd = boot.sd),
paste0(save.sims.dir, "/cv", i, "_boot_res.rds"))
}
#Stop the cluster
stopCluster(cl)
setwd("D:/Academia/Gradient matching revisit 2022/Gamma errors (imaginary cells BC)")
library(readr)
library(latex2exp)
res.dir <- c("SimRes_ests")
boots.dir <- c("SimRes_boots2")
cv <- c(0.01, 0.025, 0.05, 0.075, 0.1)
cv.1.res <- read_rds(paste0("./", res.dir, "/cv1_sim_res.rds"))
cv.2.res <- read_rds(paste0("./", res.dir, "/cv2_sim_res.rds"))
cv.3.res <- read_rds(paste0("./", res.dir, "/cv3_sim_res.rds"))
cv.4.res <- read_rds(paste0("./", res.dir, "/cv4_sim_res.rds"))
cv.5.res <- read_rds(paste0("./", res.dir, "/cv5_sim_res.rds"))
cv.1.mean.vals <- apply(cv.1.res$par.ests, 2, mean)
cv.2.mean.vals <- apply(cv.2.res$par.ests, 2, mean)
cv.3.mean.vals <- apply(cv.3.res$par.ests, 2, mean)
cv.4.mean.vals <- apply(cv.4.res$par.ests, 2, mean)
cv.5.mean.vals <- apply(cv.5.res$par.ests, 2, mean)
ests.mat <- rbind(cv.1.mean.vals, cv.2.mean.vals, cv.3.mean.vals,
cv.4.mean.vals, cv.5.mean.vals)
write.table(ests.mat, "Parameter estimates 5 cv.txt")
cv.1.true.sd <- apply(cv.1.res$par.ests, 2, sd)
cv.2.true.sd <- apply(cv.2.res$par.ests, 2, sd)
cv.3.true.sd <- apply(cv.3.res$par.ests, 2, sd)
cv.4.true.sd <- apply(cv.4.res$par.ests, 2, sd)
cv.5.true.sd <- apply(cv.5.res$par.ests, 2, sd)
true.sd.mat <- rbind(cv.1.true.sd, cv.2.true.sd, cv.3.true.sd, cv.4.true.sd,
cv.5.true.sd)
cv.1.mean.sd <- apply(cv.1.res$sd.ests, 2, mean)
cv.2.mean.sd <- apply(cv.2.res$sd.ests, 2, mean)
cv.3.mean.sd <- apply(cv.3.res$sd.ests, 2, mean)
cv.4.mean.sd <- apply(cv.4.res$sd.ests, 2, mean)
cv.5.mean.sd <- apply(cv.5.res$sd.ests, 2, mean)
mean.sd.mat <- rbind(cv.1.mean.sd, cv.2.mean.sd, cv.3.mean.sd, cv.4.mean.sd,
cv.5.mean.sd)
cv1.boots.res <- read_rds(paste0("./", boots.dir, "/cv1_boot_res.rds"))
cv2.boots.res <- read_rds(paste0("./", boots.dir, "/cv2_boot_res.rds"))
cv3.boots.res <- read_rds(paste0("./", boots.dir, "/cv3_boot_res.rds"))
cv4.boots.res <- read_rds(paste0("./", boots.dir, "/cv4_boot_res.rds"))
cv5.boots.res <- read_rds(paste0("./", boots.dir, "/cv5_boot_res.rds"))
cv1.boots.sd <- apply(cv1.boots.res$boot.sd, 2, mean)
cv2.boots.sd <- apply(cv2.boots.res$boot.sd, 2, mean)
cv3.boots.sd <- apply(cv3.boots.res$boot.sd, 2, mean)
cv4.boots.sd <- apply(cv4.boots.res$boot.sd, 2, mean)
cv5.boots.sd <- apply(cv5.boots.res$boot.sd, 2, mean)
boot.sd.mat <- rbind(cv1.boots.sd, cv2.boots.sd, cv3.boots.sd, cv4.boots.sd,
cv5.boots.sd)
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n}", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
lines(boot.sd.mat[,1], lwd = 2, col = "red")
# gamma sd comparison
plot(true.sd.mat[,2], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2]),
max(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2])),
main = TeX("SD comparison $\\gamma$", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,2], lwd = 2, col = "blue")
lines(boot.sd.mat[,2], lwd = 2, col = "red")
# rn sd comparison
plot(true.sd.mat[,3], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3]),
max(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3])),
main = TeX("SD comparison $r_{n}$", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,3], lwd = 2, col = "blue")
lines(boot.sd.mat[,3], lwd = 2, col = "red")
# eta sd comparison
plot(true.sd.mat[,4], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4]),
max(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4])),
main = TeX("SD comparison $\\eta$", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,4], lwd = 2, col = "blue")
lines(boot.sd.mat[,4], lwd = 2, col = "red")
# dm sd comparison
plot(true.sd.mat[,5], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5]),
max(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5])),
main = TeX("SD comparison $d_{m}$", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,5], lwd = 2, col = "blue")
lines(boot.sd.mat[,5], lwd = 2, col = "red")
# alpha sd comparison
plot(true.sd.mat[,6], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6]),
max(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6])),
main = TeX("SD comparison $\\alpha$", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,6], lwd = 2, col = "blue")
lines(boot.sd.mat[,6], lwd = 2, col = "red")
setwd("D:/Academia/Gradient matching revisit 2022/Normal errors")
library(readr)
library(latex2exp)
res.dir <- c("SimRes_ests")
boots.dir <- c("SimRes_boots2")
cv <- c(0.01, 0.025, 0.05, 0.075, 0.1)
cv.1.res <- read_rds(paste0("./", res.dir, "/cv1_sim_res.rds"))
cv.2.res <- read_rds(paste0("./", res.dir, "/cv2_sim_res.rds"))
cv.3.res <- read_rds(paste0("./", res.dir, "/cv3_sim_res.rds"))
cv.4.res <- read_rds(paste0("./", res.dir, "/cv4_sim_res.rds"))
cv.5.res <- read_rds(paste0("./", res.dir, "/cv5_sim_res.rds"))
cv.1.mean.vals <- apply(cv.1.res$par.ests, 2, mean)
cv.2.mean.vals <- apply(cv.2.res$par.ests, 2, mean)
cv.3.mean.vals <- apply(cv.3.res$par.ests, 2, mean)
cv.4.mean.vals <- apply(cv.4.res$par.ests, 2, mean)
cv.5.mean.vals <- apply(cv.5.res$par.ests, 2, mean)
ests.mat <- rbind(cv.1.mean.vals, cv.2.mean.vals, cv.3.mean.vals,
cv.4.mean.vals, cv.5.mean.vals)
write.table(ests.mat, "Parameter estimates 5 cv.txt")
cv.1.true.sd <- apply(cv.1.res$par.ests, 2, sd)
cv.2.true.sd <- apply(cv.2.res$par.ests, 2, sd)
cv.3.true.sd <- apply(cv.3.res$par.ests, 2, sd)
cv.4.true.sd <- apply(cv.4.res$par.ests, 2, sd)
cv.5.true.sd <- apply(cv.5.res$par.ests, 2, sd)
cv.1.mean.sd <- apply(cv.1.res$sd.ests, 2, mean)
cv.2.mean.sd <- apply(cv.2.res$sd.ests, 2, mean)
cv.3.mean.sd <- apply(cv.3.res$sd.ests, 2, mean)
cv.4.mean.sd <- apply(cv.4.res$sd.ests, 2, mean)
cv.5.mean.sd <- apply(cv.5.res$sd.ests, 2, mean)
cv1.boots.res <- read_rds(paste0("./", boots.dir, "/cv1_boot_res.rds"))
cv2.boots.res <- read_rds(paste0("./", boots.dir, "/cv2_boot_res.rds"))
cv3.boots.res <- read_rds(paste0("./", boots.dir, "/cv3_boot_res.rds"))
cv4.boots.res <- read_rds(paste0("./", boots.dir, "/cv4_boot_res.rds"))
cv5.boots.res <- read_rds(paste0("./", boots.dir, "/cv5_boot_res.rds"))
cv1.boots.sd <- apply(cv1.boots.res$boot.sd, 2, mean)
cv2.boots.sd <- apply(cv2.boots.res$boot.sd, 2, mean)
cv3.boots.sd <- apply(cv3.boots.res$boot.sd, 2, mean)
cv4.boots.sd <- apply(cv4.boots.res$boot.sd, 2, mean)
cv5.boots.sd <- apply(cv5.boots.res$boot.sd, 2, mean)
boot.sd.mat <- rbind(cv1.boots.sd, cv2.boots.sd, cv3.boots.sd, cv4.boots.sd,
cv5.boots.sd)
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n}", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
lines(boot.sd.mat[,1], lwd = 2, col = "red")
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n} (Gaussian errors)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
# dn sd comparison
plot(true.sd.mat[,1], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1]),
max(true.sd.mat[,1], mean.sd.mat[,1], boot.sd.mat[,1])),
main = TeX("SD comparisons $d_{n}$ (Gaussian errors)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,1], lwd = 2, col = "blue")
lines(boot.sd.mat[,1], lwd = 2, col = "red")
# gamma sd comparison
plot(true.sd.mat[,2], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2]),
max(true.sd.mat[,2], mean.sd.mat[,2], boot.sd.mat[,2])),
main = TeX("SD comparison $\\gamma$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,2], lwd = 2, col = "blue")
lines(boot.sd.mat[,2], lwd = 2, col = "red")
# rn sd comparison
plot(true.sd.mat[,3], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3]),
max(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3])),
main = TeX("SD comparison $r_{n}$", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,3], lwd = 2, col = "blue")
lines(boot.sd.mat[,3], lwd = 2, col = "red")
# eta sd comparison
plot(true.sd.mat[,4], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4]),
max(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4])),
main = TeX("SD comparison $\\eta$", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,4], lwd = 2, col = "blue")
lines(boot.sd.mat[,4], lwd = 2, col = "red")
# rn sd comparison
plot(true.sd.mat[,3], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3]),
max(true.sd.mat[,3], mean.sd.mat[,3], boot.sd.mat[,3])),
main = TeX("SD comparison $r_{n}$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,3], lwd = 2, col = "blue")
lines(boot.sd.mat[,3], lwd = 2, col = "red")
# eta sd comparison
plot(true.sd.mat[,4], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4]),
max(true.sd.mat[,4], mean.sd.mat[,4], boot.sd.mat[,4])),
main = TeX("SD comparison $\\eta$ (Gaussian errors)", bold = TRUE), xlab = "CVs",
ylab = "SD")
lines(mean.sd.mat[,4], lwd = 2, col = "blue")
lines(boot.sd.mat[,4], lwd = 2, col = "red")
# dm sd comparison
plot(true.sd.mat[,5], type = "l", lwd = 2, col = "black",
main = TeX("SD comparison $d_{m} (Gaussian erros)$", bold = TRUE),
ylim = c(min(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5]),
max(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5])),
xlab = "CVs", ylab = "SD")
# dm sd comparison
plot(true.sd.mat[,5], type = "l", lwd = 2, col = "black",
main = TeX("SD comparison $d_{m}$ (Gaussian erros)", bold = TRUE),
ylim = c(min(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5]),
max(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5])),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,5], lwd = 2, col = "blue")
lines(boot.sd.mat[,5], lwd = 2, col = "red")
# dm sd comparison
plot(true.sd.mat[,5], type = "l", lwd = 2, col = "black",
main = TeX("SD comparison $d_{m}$ (Gaussian errors)", bold = TRUE),
ylim = c(min(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5]),
max(true.sd.mat[,5], mean.sd.mat[,5], boot.sd.mat[,5])),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,5], lwd = 2, col = "blue")
lines(boot.sd.mat[,5], lwd = 2, col = "red")
# alpha sd comparison
plot(true.sd.mat[,6], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6]),
max(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6])),
main = TeX("SD comparison $\\alpha (Gaussian errors$", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,6], lwd = 2, col = "blue")
# alpha sd comparison
plot(true.sd.mat[,6], type = "l", lwd = 2, col = "black",
ylim = c(min(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6]),
max(true.sd.mat[,6], mean.sd.mat[,6], boot.sd.mat[,6])),
main = TeX("SD comparison $\\alpha$ (Gaussian errors)", bold = TRUE),
xlab = "CVs", ylab = "SD")
lines(mean.sd.mat[,6], lwd = 2, col = "blue")
lines(boot.sd.mat[,6], lwd = 2, col = "red")
