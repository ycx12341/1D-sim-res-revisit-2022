dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
# Initial values
n <- n0
f0 <- 1-0.5*n0
f <- f0
m0 <- 0.5*n0
m <- m0
#Generate reference dataset
ref.data <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0)
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
cl <- makeCluster(n.threads/2)
registerDoParallel(cl)
#Set parallel seed - once = TRUE means it's set each time foreach is called
registerDoRNG(rn.seed, once = TRUE)
#Start the timer
tic()
for(i in 1:length(cv)) {
#Run the simulation in parallel
ests <- foreach (sim = 1:n.sims, .combine = rbind) %dopar% {
#Introduce random error
pert.data <- perturb.reference.data(ref.data, cv = cv[i], distribution = dist)
if(save.sims)
readr::write_rds(list(ref.data = ref.data, pert.data = pert.data),
path = paste0("./", save.sims.dir,
"/cv", i, "_pert_data", sim, "_rds"))
#Vector to return from the foreach
c(i, sim)
}
}
toc()
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations")
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("/cv", 1, "_pert_data", i, "_rds"))
pert.data <- pert.data.res$pert.data
#mean.var.mat <- matrix(length(pert.data$n[,1]))
}
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022")
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022")
### ABC scheme ########
### Author: Yunchen Xiao & Len Thomas ###########
rm(list = ls())
#Source companion functions
source("PDE_ABC_NoisyDataGeneration_Functions.r")
#Load the package "tictoc" in order to measure the computational time.
library(tictoc)
#Load "readr" package for writing results - just check it's loaded
#(it's actually used first inside the parallel routine)
library(readr)
#Load packages for running the simulation in parallel
library(doParallel)
library(doRNG)
#Define simulation parameters
#Measurement error CV levels to run (if a scalar then just runs at this one level)
cv <- c(0.01, 0.025, 0.05, 0.075, 0.10)
#Measurement error distribution
dist = "normal"
#Number of simulations at each level of CV
n.sims <- 10
#Whether to save simulation outputs to file or not
# (useful as they are time-consuming to run, and this
# allows further post-processing on results)
save.sims <- TRUE
save.sims.dir <- "Noisy_Data"
#Set random number seed so results are reproducible
# (random number set within each level of CV to make any repeat runs of a
#  single CV level easier)
rn.seed <- 874513
#Number of parallel threads to run on
n.threads <- detectCores() - 1
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
# Initial values
n <- n0
f0 <- 1-0.5*n0
f <- f0
m0 <- 0.5*n0
m <- m0
#Generate reference dataset
ref.data <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0)
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
### ABC scheme ########
### Author: Yunchen Xiao & Len Thomas ###########
rm(list = ls())
#Source companion functions
source("PDE_ABC_NoisyDataGeneration_Functions.r")
#Load the package "tictoc" in order to measure the computational time.
library(tictoc)
#Load "readr" package for writing results - just check it's loaded
#(it's actually used first inside the parallel routine)
library(readr)
#Load packages for running the simulation in parallel
library(doParallel)
library(doRNG)
#Define simulation parameters
#Measurement error CV levels to run (if a scalar then just runs at this one level)
cv <- c(0.01, 0.025, 0.05, 0.075, 0.10)
#Measurement error distribution
dist = "normal"
#Number of simulations at each level of CV
n.sims <- 10
#Whether to save simulation outputs to file or not
# (useful as they are time-consuming to run, and this
# allows further post-processing on results)
save.sims <- TRUE
save.sims.dir <- "Noisy_Data"
#Set random number seed so results are reproducible
# (random number set within each level of CV to make any repeat runs of a
#  single CV level easier)
rn.seed <- 874513
#Number of parallel threads to run on
n.threads <- detectCores() - 1
# Define model parameters
dn <- 0.01
gamma <- 0.05
eta <- 10
dm <- 0.01
alpha <- 0.1
rn <- 5
# This parameter not included in the optimization
beta <- 0
# Make a vector to store the true values
true.values <- c(dn, gamma, rn, eta, dm, alpha)
names(true.values) <- c("dn", "gamma", "rn", "eta", "dm", "alpha")
# Define 1D dimensionless space points
n.x11 <- 80
max.x11 <- 1
x11 <- seq(0, max.x11, length = n.x11)
# Define time discretization and max time
dt <- 0.001
max.t <- 10
# Set initial conditions
eps <- 0.01
n0 <- rep(0, n.x11)
for (i in 1:n.x11) {
if (x11[i] <= 0.25) {
n0[i] <- exp(-x11[i] ^ 2 / eps)
} else {
n0[i] <- 0
}
}
# Initial values
n <- n0
f0 <- 1-0.5*n0
f <- f0
m0 <- 0.5*n0
m <- m0
#Generate reference dataset
ref.data <- generate.reference.data(n.x11, max.x11, dt, max.t,
dn, gamma, eta, dm, alpha, rn, beta, n0, f0, m0)
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
cl <- makeCluster(n.threads/2)
registerDoParallel(cl)
#Set parallel seed - once = TRUE means it's set each time foreach is called
registerDoRNG(rn.seed, once = TRUE)
tic()
for(i in 1:length(cv)) {
#Run the simulation in parallel
ests <- foreach (sim = 1:n.sims, .combine = rbind) %dopar% {
#Introduce random error
pert.data <- perturb.reference.data(ref.data, cv = cv[i], distribution = dist)
if(save.sims)
readr::write_rds(list(ref.data = ref.data, pert.data = pert.data),
path = paste0("./", save.sims.dir,
"/cv", i, "_pert_data", sim, ".rds"))
#Vector to return from the foreach
c(i, sim)
}
}
toc()
View(ests)
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations")
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations")
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("/cv", 1, "_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
#mean.var.mat <- matrix(length(pert.data$n[,1]))
}
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("/cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
#mean.var.mat <- matrix(length(pert.data$n[,1]))
}
read_rds("cv1_pert_data1.rds")
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("./cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
#mean.var.mat <- matrix(length(pert.data$n[,1]))
}
View(pert.data)
length(pert.data$n[,1])
length(pert.data$n[,2])
length(pert.data$n[1,])
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("./cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
n.temp <- pert.data$n
f.temp <- pert.data$f
m.data <- pert.data$m
#mean.var.mat <- matrix(length(pert.data$n[1,]))
#mean.var.mat[1:80, ] <- c(mean(m))
}
View(n.temp)
mean.var.mat <- matrix(0, nrow = length(pert.data$n[1,]) * 3, ncol = 2)
apply(n.temp, 2, mean)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("./cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
n.temp <- pert.data$n
f.temp <- pert.data$f
m.temp <- pert.data$m
ncol.data <- length(n.temp[1,])
mean.var.mat <- matrix(0, nrow = ncol.data * 3, ncol = 2)
mean.var.mat[1:ncol.data, 1] <- apply(n.temp, 2, mean)
mean.var.mat[1:ncol.data, 2] <- apply(n.temp, 2 ,var)
mean.var.mat[(ncol.data + 1):ncol.data * 2, 1] <- apply(f.temp, 2, mean)
mean.var.mat[(ncol.data + 1):ncol.data * 2, 2] <- apply(f.temp, 2, var)
mean.var.mat[(ncol.data * 2 + 1):ncol.data * 3, 1] <- apply(m.temp, 2, mean)
mean.var.mat[(ncol.data * 2 + 1):ncol.data * 3, 2] <- apply(m.temp, 2, var)
write_rds(list(ss.mat = mean.var.mat),
paste0("./cv1_pert_data", i, "_ss.rds"))
}
View(mean.var.mat)
ncol.data + 1
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("./cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
n.temp <- pert.data$n
f.temp <- pert.data$f
m.temp <- pert.data$m
ncol.data <- length(n.temp[1,])
mean.var.mat <- matrix(0, nrow = ncol.data * 3, ncol = 2)
mean.var.mat[1:ncol.data, 1] <- apply(n.temp, 2, mean)
mean.var.mat[1:ncol.data, 2] <- apply(n.temp, 2 ,var)
mean.var.mat[(ncol.data + 1):(ncol.data * 2), 1] <- apply(f.temp, 2, mean)
mean.var.mat[(ncol.data + 1):(ncol.data * 2), 2] <- apply(f.temp, 2, var)
mean.var.mat[(ncol.data * 2 + 1):(ncol.data * 3), 1] <- apply(m.temp, 2, mean)
mean.var.mat[(ncol.data * 2 + 1):(ncol.data * 3), 2] <- apply(m.temp, 2, var)
write_rds(list(ss.mat = mean.var.mat),
paste0("./cv1_pert_data", i, "_ss.rds"))
}
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations")
View(mean.var.mat)
View(pert.data)
View(pert.data.res)
mean(pert.data.res$ref.data$f[,1])
View(m.temp)
View(pert.data.res)
pert.data.res[["pert.data"]][["n"]]
pert.data.res[["ref.data"]][["n"]]
kkk <- pert.data.res$ref.data$n
View(kkk)
n.trun.temp <- pert.data$n[-1,]
View(n.trun.temp)
rm(list = ls())
library(readr)
n.data <- 10
for (i in 1:n.data) {
pert.data.res <- read_rds(paste0("./cv1_pert_data", i, ".rds"))
pert.data <- pert.data.res$pert.data
n.temp <- pert.data$n[-1,]
f.temp <- pert.data$f[-1,]
m.temp <- pert.data$m[-1,]
ncol.data <- length(n.temp[1,])
mean.var.mat <- matrix(0, nrow = ncol.data * 3, ncol = 2)
mean.var.mat[1:ncol.data, 1] <- apply(n.temp, 2, mean)
mean.var.mat[1:ncol.data, 2] <- apply(n.temp, 2 ,var)
mean.var.mat[(ncol.data + 1):(ncol.data * 2), 1] <- apply(f.temp, 2, mean)
mean.var.mat[(ncol.data + 1):(ncol.data * 2), 2] <- apply(f.temp, 2, var)
mean.var.mat[(ncol.data * 2 + 1):(ncol.data * 3), 1] <- apply(m.temp, 2, mean)
mean.var.mat[(ncol.data * 2 + 1):(ncol.data * 3), 2] <- apply(m.temp, 2, var)
write_rds(list(ss.mat = mean.var.mat),
paste0("./cv1_pert_data", i, "_ss.rds"))
}
View(mean.var.mat)
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations/Dataset 1")
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations/Dataset 1")
cv1_pert_data1_ss <- readRDS("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations/Dataset 1/cv1_pert_data1_ss.rds")
View(cv1_pert_data1_ss)
View(cv1_pert_data1_ss)
cv1_pert_data1_ss[["ss.mat"]]
ggg <- read_rds("cv1_pert_data1_ss.rds")$ss.mat
# Clear the current workspace and load the necessary packages.
rm(list = ls())
library(doParallel)
library(doRNG)
library(tictoc)
library(readr)
# source functions
source("Automatic.R")
# Optional line: set the directory to store the simulation results in .rds
# files.
save.sims.dir <- "BCD_results_ecm_r1"
save.sims <- TRUE
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
# Generate the initial parameters used in the evaluations of ECM density
# profile.
set.seed(123)
dn<-runif(10000,0.000069,0.02)
gamma<-runif(10000,0.005,0.26)
eta<-runif(10000,7,18)
dm<-runif(10000,0.0001,0.033)
alpha<-runif(10000,0.07,0.18)
rn<-runif(10000,3.5,9)
paras.ecm.r1 <- cbind(dn,gamma,eta,dm,alpha,rn)
View(paras.ecm.r1)
set.seed(123)
RNGkind(sample.kind = "Rejection")
dn<-runif(10000,0.000069,0.02)
gamma<-runif(10000,0.005,0.26)
eta<-runif(10000,7,18)
dm<-runif(10000,0.0001,0.033)
alpha<-runif(10000,0.07,0.18)
rn<-runif(10000,3.5,9)
paras.ecm.r1 <- cbind(dn,gamma,eta,dm,alpha,rn)
write.table(paras.ecm.r1,"Round 1 parameters 10000 ecm.txt")
setwd("D:/Academia/1D material revisit 2022/ABC BCD revisit 2022/CV 1 data simulations/Dataset 1")
paras.ecm.r1 <- as.matrix(read.table("Round 1 parameters 10000 ecm.txt", sep = "",
header = TRUE))
# Set up the parallel running scheme.
n.thread <- detectCores() - 1
n.sims <- 10000
cl <- makeCluster(n.thread)
registerDoParallel(cl)
tic()
ests <- foreach (i = 1:n.sims, .combine = rbind) %dopar% {
bcd.temp <- bcd(paras = paras.ecm.r1[i,], paras.ind = "ecm")
# Optional line: write the results into .rds files.
readr::write_rds(bcd.temp,
path = paste0("./", save.sims.dir, "/Round_1_paras", i, "_res.rds"))
c(i, bcd.temp)
}
toc()
stopCluster(cl)
# Clear the current workspace and load the necessary packages.
rm(list = ls())
library(doParallel)
library(doRNG)
library(tictoc)
library(readr)
# source functions
source("Automatic.R")
# Optional line: set the directory to store the simulation results in .rds
# files.
save.sims.dir <- "BCD_results_ecm_r1"
save.sims <- TRUE
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
# Generate the initial parameters used in the evaluations of ECM density
# profile.
set.seed(123)
RNGkind(sample.kind = "Rejection")
set.seed(123)
RNGkind(sample.kind = "Rejection")
dn<-runif(10000,0.000069,0.02)
gamma<-runif(10000,0.005,0.26)
eta<-runif(10000,7,18)
dm<-runif(10000,0.0001,0.033)
alpha<-runif(10000,0.07,0.18)
rn<-runif(10000,3.5,9)
paras.ecm.r1 <- cbind(dn,gamma,eta,dm,alpha,rn)
set.seed(123)
RNGkind(sample.kind = "Rejection")
dn<-runif(10000,0.000069,0.02)
gamma<-runif(10000,0.005,0.26)
eta<-runif(10000,7,18)
dm<-runif(10000,0.0001,0.033)
alpha<-runif(10000,0.07,0.18)
rn<-runif(10000,3.5,9)
paras.ecm.r1 <- cbind(dn,gamma,eta,dm,alpha,rn)
write.table(paras.ecm.r1,"Round 1 parameters 10000 ecm.txt")
paras.ecm.r1 <- as.matrix(read.table("Round 1 parameters 10000 ecm.txt", sep = "",
header = TRUE))
# Set up the parallel running scheme.
n.thread <- detectCores() - 1
n.sims <- 10000
cl <- makeCluster(n.thread)
registerDoParallel(cl)
tic()
ests <- foreach (i = 1:n.sims, .combine = rbind) %dopar% {
bcd.temp <- bcd(paras = paras.ecm.r1[i,], paras.ind = "ecm")
# Optional line: write the results into .rds files.
readr::write_rds(bcd.temp,
path = paste0("./", save.sims.dir, "/Round_1_paras", i, "_res.rds"))
c(i, bcd.temp)
}
toc()
stopCluster(cl)
# Clear the current workspace and load the necessary packages.
rm(list = ls())
library(doParallel)
library(doRNG)
library(tictoc)
library(readr)
# source functions
source("Automatic.R")
# Optional line: set the directory to store the simulation results in .rds
# files.
save.sims.dir <- "BCD_results_ecm_r1"
save.sims <- TRUE
if(save.sims) {
if(!dir.exists(save.sims.dir)) dir.create(save.sims.dir)
}
# Generate the initial parameters used in the evaluations of ECM density
# profile.
set.seed(123)
RNGkind(sample.kind = "Rejection")
dn<-runif(10000,0.000069,0.02)
gamma<-runif(10000,0.005,0.26)
eta<-runif(10000,7,18)
dm<-runif(10000,0.0001,0.033)
alpha<-runif(10000,0.07,0.18)
rn<-runif(10000,3.5,9)
paras.ecm.r1 <- cbind(dn,gamma,eta,dm,alpha,rn)
write.table(paras.ecm.r1,"Round 1 parameters 10000 ecm.txt")
paras.ecm.r1 <- as.matrix(read.table("Round 1 parameters 10000 ecm.txt", sep = "",
header = TRUE))
# Set up the parallel running scheme.
n.thread <- detectCores() - 1
n.sims <- 10000
cl <- makeCluster(n.thread)
registerDoParallel(cl)
tic()
ests <- foreach (i = 1:n.sims, .combine = rbind) %dopar% {
bcd.temp <- bcd(paras = paras.ecm.r1[i,], paras.ind = "ecm")
# Optional line: write the results into .rds files.
readr::write_rds(bcd.temp,
path = paste0("./", save.sims.dir, "/Round_1_paras", i, "_res.rds"))
c(i, bcd.temp)
}
toc()
stopCluster(cl)
View(ests)
write.table(ests, "bcd_ecm_r1.txt")
bcd.ecm.r1 <- unname(ests)
ind.nan.ecm.r1 <- which(is.na(bcd.ecm.r1[,2]))
bcd.ecm.r1.valid <- bcd.ecm.r1[-ind.nan.ecm.r1,]
mean(bcd.ecm.r1.valid[,2]) # 3.408093
min(bcd.ecm.r1.valid[,2]) # 0.02653616
# Resample and record the parameters to be evaluated in the next round.
paras.ecm.r2 <- abc.bcd(ss.mat = bcd.ecm.r1, paras = paras.ecm.r1, bw = 0.5)
# source functions
source("Automatic.R")
set.seed(123)
RNGkind(sample.kind = "Rejection")
paras.ecm.r2 <- abc.bcd(ss.mat = bcd.ecm.r1, paras = paras.ecm.r1, bw = 0.5)
write.table(paras.ecm.r2, "Round 2 parameters 10000 ecm.txt")
